Creating a bundle
~~~~~~~~~~~~~~~~~

We can use maven plugin to create an iPOJO artifact.

[source,bash]
--
mvn org.apache.maven.plugins:maven-archetype-plugin:generate \
-DinteractiveMode=false \
-DarchetypeArtifactId=maven-ipojo-plugin \
-DarchetypeGroupId=org.apache.felix \
-DarchetypeVersion=1.11.0 \
-DartifactId=config \
-DgroupId=org.adele \
-Dpackage=org.adele \
-Dversion=0.0.1-EXAMPLE
--

Make sure to add *Fuchsia* dependency:

[source,xml]
--
<dependency>
    <groupId>org.ow2.chameleon.fuchsia</groupId>
    <artifactId>fuchsia-core</artifactId>
    <version>0.0.1</version>
</dependency>
--

That is it, now you are ready to add your custom code.

[WARNING]
====
Make sure to replace the version *0.0.1* of Fuchsia, by the version that you are using
====

Import a JAX-WS service
~~~~~~~~~~~~~~~~~~~~~~~

After create your project, we have couple tasks to accomplish before be able to use the imported JAX-WS service:

.Prepare the environment
- [ ] Instantiate the importer
- [ ] Instantiate the linker

.As result of fuchsia
- [ ] Inform fuchsia the JAX-WS info
- [ ] Fetch your local instance

Preparation
^^^^^^^^^^^

One step at a time, so lets first instantiate our importer, we first need to find out the name of our importer JAX-WS, which is _Fuchsia_importer.cxf_, with that in mind we can instantiate it indicating what are the *Declarations* that he should consider as a declaration that concerns it. 

In our case we may say that, any declaration containing a value for the key *endpoint.url*, is a valid declaration to be processed by this importer, thus this give us:

[source]
--
    Instance cxfimporter = Instance.instance()
            .of("Fuchsia_importer.cxf")
            .with("target").setto("(endpoint.url=*)");
--

With this we can check our first task *Instantiate the importer*. Following our list we have instantiated the *Linker*.

The *Linkers* job is to evaluate if a given *Declaration* and a *Service* match together, so essentially he impose the condition in order to connect this two entities. We can instantiate our linker in following manner:

[source]
--
    Instance cxfimporterlinker = instance()
            .of("FuchsiaDefaultImportationLinkerFactory")
            .with("fuchsia.linker.filter.importDeclaration").setto("(endpoint.url=*)")
            .with("fuchsia.linker.filter.importerService").setto("(instance.name=cxfimporterlinker)");
--

In this linker we are saying "if a declaration constains _endpoint.url_ than connect it with the importer in which the instance is called _cxfimporterlinker_".

In order to _Inform fuchsia the JAX-WS info_, we have several options, either we can publish a service that follows the interface _org.ow2.chameleon.fuchsia.core.declaration.ImportDeclaration_, or we can use the Fake-Discovery, which translate files deployed in the folder named _load_ into a ImportDeclaration.

You can check that everything is up and running by typing *importer* on the console, you should see at least:

[source]
--
Importer [cxfimporter] provided by bundle cxf-importer (46)
	*importer name = cxfimporter
	Service properties:
		factory.name = Fuchsia_importer.cxf
		instance.name = cxfimporter
		objectClass = [Ljava.lang.String;@191c428
		service.id = 335
		target = (endpoint.url=*)
--

And check that the FakeDiscovery is running as well by typing *discovery* and you will see:

[source]
--
Discovery [Fuchsia-FakeDiscovery] provided by bundle fuchsia-fake-discovery (37)
	Service properties:
		factory.name = Fuchsia-FakeDiscovery-Factory
		fuchsia.system.fake.discovery.directory = load
		fuchsia.system.fake.discovery.polling = 2000
		instance.name = Fuchsia-FakeDiscovery
		objectClass = [Ljava.lang.String;@20e9c6
		service.id = 321

--

Result
^^^^^^

So far we've our checklist look like this:

- [*] Instantiate the importer
- [*] Instantiate the linker
- [ ] Inform fuchsia the JAX-WS info
- [ ] Use the remote instance

The last two steps consist in informing the Fuchsia the address of our JAX-WS service. For that its enough to deploy a file in the folder _load_ (thanks to the Fake-Discovery) with the following content:

[source]
--
id=virtual-camera
className=org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface
jax-ws.importer.interfaces=[org.ow2.chameleon.fuchsia.exporter.cxf.examples.base.PojoSampleToBeExportedIface]
endpoint.url=http://localhost:8080/cxf/service/PojoSampleToBeExportedIface

deviceType=camera
deviceSubType=another
device.serialNumber=virtual-camera
--

Then, just request your service as a regular dependency (as shown below), then you ll see your dependency being injected and ready for use without much trouble.

[source,java]
--
@Component
@Instantiate
public class Client {

    @Requires
    PojoSampleToBeExportedIface myRemoteService;

    @Validate
    public void validate(){

        System.out.println("---->"+myRemoteService.getMessage2());

    }

}
--


Import a PuSH service
~~~~~~~~~~~~~~~~~~~~~

PubSubHubbub (PuSH) is a google protocol create to be fast, in fact it is a publish / subscribe mechanism that avoids the polling technique. A small diagram can show you the idea behind the protocol

image:diagram/push01.svg["PuSH",width=800]

Prepare
^^^^^^^

So we are going to need, we are assuming that the publisher and hub addresses are well known.

- [*] know the address of the publisher
- [*] know the address of the hub
- [ ] Instantiate the Importer
- [ ] Instantiate the linker
- [ ] Inform fuchsia the Hub and Publisher addresses
- [ ] Visualize the messages

The first two steps you have to know already those addresses, the next two steps can be done by using maven profile. Meaning that we can generate a chameleon distribution with all our fuchsia dependencies, linker and importer instantiated just by typing into the project repository:

[source,bash]
--
mvn clean install -f distribution/pom.xml -Pcore,push,push-config,fake && \
cd distribution/target/chameleon-distribution/ && \
sh chameleon.sh --interactive
--

Now lets verify our checklist:

- [*] know the address of the publisher
- [*] know the address of the hub
- [*] Instantiate the Importer
- [*] Instantiate the linker
- [*] Inform fuchsia the Hub and Publisher addresses
- [ ] Visualize the messages

The next step is done by add a file with all the information we already have about the PuSH server (example of the file below)

[source,bash]
--
id=push-dispatch-event-admin
deviceType=camera
deviceSubType=another

push.hub.topic=http://blogname.blogspot.com/feeds/posts/default
push.hub.url=http://localhost:8080/hub/subscribe
push.subscriber.callback=http://localhost:8080/push
push.eventAdmin.queue=public

device.serialNumber=push-dispatch-event-admin
--

[WARNING]
====
The client must be accessible from the hub, since the hub is the one that pushes the change into clients callback
====

So we are able to see the redirection (from PuSH into Event admin) we install http://www.interior-dsgn.com/apache//felix/org.apache.felix.webconsole.plugins.event-1.1.0.jar[Web Console Event Admin Plugin].

By default fuchsia distribution will install the _felix webconsole_, that can be access in the URL http://localhost:8080/system/console/events.

Now when you receive an update from the _Hub_ it will be automatically redirected to eventAdmin message bus.

Import a MQTT service
~~~~~~~~~~~~~~~~~~~~~

As MQTT is an efficient message exchange protocole, Fuchsia has builtin a *MQTT* importer that receives and forward messages from MQTT bus into EventAdmin bus. 

The address of the MQTT server is supposely known, and the next two steps (importer and linker instantiation) can be done with the maven profile, according to the command below.

[source,bash]
--
mvn clean install -f distribution/pom.xml -Pcore,mqtt,mqtt-config,fake && \
cd distribution/target/chameleon-distribution/ && \
sh chameleon.sh --interactive
--  

So lets verify how are we in relation to our checklist:

Lets create our checklist:

- [*] know the address of the MQTT server
- [*] Instantiate the Importer
- [*] Instantiate the linker
- [ ] Inform fuchsia about the MQTT server address
- [ ] Visualize the messages

We tell Fuchsia which MQTT server (and other parameters) by deploying a file into the _load_ directory containing those info (with the content below):

[source,bash]
--
id=mqtt-dispatch-event-admin
deviceType=camera
deviceSubType=another

mqtt.queue=public
mqtt.server.host=localhost
mqtt.server.port=5672
-- 

You can use http://localhost:8080/system/console/event[WebConsole] to see all the messages that come from MQTT and redirected to *EventAdmin*. The information *mqtt.server.host* and *mqtt.server.port* are optional, in case those informations are not available it will use the information defined as default by *RabbitMQ*.

So, after installing your MQTT server (in our case RabbitMQ) make sure its running 

[source,bash]
--
sudo /etc/init.d/rabbitmq-server status
--


